#!/usr/bin/python
"""
Create network based on provided network file

- virtual Site entities are created
- virtual Cell entities are created
- corresponding Cell->Site and Site->Cell relations are created
- gis Site entities are created
- gis Cell entities are created

"""
import sys
import os
import argparse
import logging
from datetime import datetime, timedelta
from contextlib import closing
from logging.handlers import RotatingFileHandler
from functools import partial
import pytz
from operator import mul
from itertools import imap
from StringIO import StringIO

from configobj import ConfigObj

from minerva import __version__ as version
from minerva.db import connect
from minerva.directory.relation import add_relations, reverse_relations
from minerva.storage import get_plugin
from minerva.directory.helpers import create_entity
from minerva.util.config import parse_size
from minerva.util import compose, zipapply, keys_to_values, reorderer


DEFAULT_CONFIG = """\
db_uri = postgresql://minerva:minerva@localhost/minerva
profile_directory =/usr/local/lib/minerva/profiles
log_directory =/var/log/minerva
log_filename = create-network.log
log_rotation_size = 10MB
log_level = INFO"""


DEFAULT_PROFILE = """\
MULTIPLY_LON_BY = 1
MULTIPLY_LAT_BY = 1
SRID = 28992"""


def main():
    parser = argparse.ArgumentParser(
        description="Create network based on provided network file with "
        "columns site cellid lat lon azimuth type")

    parser.add_argument(
        "--version", action="version", version=version,
        help="display version information and exit")

    parser.add_argument(
        "network_definition_file",
        help="Network defining csv-like file with columns site, "
        "cellid, lat, lon, azimuth, type")

    parser.add_argument(
        "-c", "--configfile", dest="configfile",
        default="/etc/minerva/create-network/default.conf",
        help="path to config file")

    parser.add_argument(
        "-p", "--profile", dest="profile",
        default="default", help="default profile")

    parser.add_argument(
        "-v", "--verbose", action="store_true", default=False,
        help="verbose output")

    parser.add_argument(
        "--generate-configfile", action=GenerateConfigFileAction, nargs=0,
        help="generate default config file")

    parser.add_argument(
        "--generate-profile", action=GenerateProfileFileAction, nargs=0,
        help="generate default profile file")

    args = parser.parse_args()

    config = get_config(args)

    setup_logging(args.verbose)
    setup_file_logging(
        config["log_directory"], config["log_filename"],
        config["log_rotation_size"], config["log_level"])

    profile = get_profile(args, config)

    with closing(connect(config["db_uri"])) as conn:

        with closing(open(args.network_definition_file, "r")) as f:
            parse_network_file(conn, f, profile)

    return 0


COLUMN_TYPES = {
    "site": str,
    "cellid": str,
    "lat": float,
    "lon": float,
    "azi": float,
    "type": str}


DEFAULT_COLUMN_ORDER = ["site", "cellid", "lat", "lon", "azi", "type"]


def parse_network_file(conn, f, profile):
    """
    Parse network file.

    It is assumed that :
    - ';' is separation character
    - first line contains column headers: site;cellid;lat;lon;azi;type

    """
    # Stub timestamp
    utc_now = pytz.UTC.localize(datetime.utcnow() - timedelta(days=400))

    relations = []
    sites = []
    cells = []
    srid = int(profile["SRID"])

    for record in read_network_records(profile, f):
        sitenr, cellid, lat, lon, azimuth, type = record

        site = create_entity(conn, "Site={0}".format(sitenr))
        cell = create_entity(conn, "Cell={0}".format(cellid))

        relations.append((site.id, cell.id))
        sites.append((site.id, utc_now, lat, lon))
        cells.append((cell.id, utc_now, lat, lon, azimuth, type))

    add_relations(conn, relations, "Site->Cell")
    add_relations(conn, reverse_relations(relations), "Cell->Site")

    geospatial = get_plugin("geospatial")(conn)

    geospatial.store_sites(sites, srid)
    geospatial.store_cells(cells, srid)


def read_network_records(profile, stream):
    column_headers = line_to_record(stream.readline())

    lat_factor = float(profile["MULTIPLY_LAT_BY"])
    lon_factor = float(profile["MULTIPLY_LON_BY"])

    multiply_lat = partial(mul, lat_factor)
    multiply_lon = partial(mul, lon_factor)

    value_parsers = keys_to_values(COLUMN_TYPES, column_headers)

    reorder_values = reorderer(DEFAULT_COLUMN_ORDER, column_headers)

    value_mapping = (identity, identity, multiply_lat, multiply_lon,
                     identity, identity)
    process_record = partial(zipapply, value_mapping)

    reorder_and_process = compose(process_record, reorder_values)

    records = read_records(value_parsers, stream)

    return imap(reorder_and_process, records)


def read_records(value_parsers, stream):
    process_record = partial(zipapply, value_parsers)
    process_line = compose(process_record, line_to_record)

    return imap(process_line, stream)


def line_to_record(line):
    return line.rstrip().split(";")


identity = lambda x: x


def setup_logging(verbose):
    root_logger = logging.getLogger("")

    if verbose:
        handler = logging.StreamHandler(sys.stdout)

        root_logger.addHandler(handler)

    root_logger.setLevel(logging.INFO)


def setup_file_logging(directory, filename, rotation_size, level):
    """Setup rotating file logging."""
    level_map = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL}

    max_log_size = parse_size(rotation_size)

    filepath = os.path.join(directory, filename)
    handler = RotatingFileHandler(filepath, maxBytes=max_log_size,
                                  backupCount=5)
    handler.setLevel(level_map[level])

    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    handler.setFormatter(formatter)

    rootlogger = logging.getLogger("")
    rootlogger.setLevel(level_map[level])
    rootlogger.addHandler(handler)


class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        print(DEFAULT_CONFIG)
        sys.exit(0)


def get_config(args):

    config = ConfigObj(StringIO(DEFAULT_CONFIG))

    if os.path.isfile(args.configfile):
        custom_config = ConfigObj(args.configfile)
        config.merge(custom_config)
    else:
        print("'{0}' doesn't exist. Using default config.".format(
            args.configfile))

    return config


class GenerateProfileFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        print(DEFAULT_PROFILE)
        sys.exit(0)


def get_profile(args, config):
    profile = ConfigObj(StringIO(DEFAULT_PROFILE))

    profile_path = None

    if os.path.isfile(args.profile):
        profile_path = args.profile
    elif os.path.isfile(os.path.join(config["profile_directory"], args.profile)):
        profile_path = os.path.join(config["profile_directory"], args.profile)

    if profile_path:
        profile.merge(ConfigObj(profile_path))
    else:
        logging.info(
            "Profile '{0}' not found. Using default profile".format(args.profile))

    return profile


if __name__ == "__main__":
    sys.exit(main())
