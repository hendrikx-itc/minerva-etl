#!/usr/bin/python
"""
Link entity tags with entities
"""
import os
import sys
import argparse
import traceback
import logging
from contextlib import closing
from operator import itemgetter
from pkg_resources import resource_string
from StringIO import StringIO

from configobj import ConfigObj

from minerva import __version__ as version
from minerva.instance import MinervaInstance
from minerva.directory.tag import NoSuchTagError, get_tag, create_tag, \
    tag_entities, flush_tag_links, create_tag_group

CONFIG_DEFAULTS = resource_string("minerva", "defaults/link-entity-tags.conf")


def main():
    default_minerva_instance = os.environ.get(
        "DEFAULT_MINERVA_INSTANCE", "default")

    parser = argparse.ArgumentParser(
        description="Create tags between entities")

    parser.add_argument(
        "--version", action="version", version=version,
        help="display version information and exit")

    parser.add_argument(
        "-i", "--instance", default=default_minerva_instance,
        help="name of the minerva instance")

    parser.add_argument("-u", "--user", help="user to connect to database")

    parser.add_argument(
        "-t", "--tag-type",
        help="name of the module containing the tag type definition")

    parser.add_argument(
        "-c", "--configfile", dest="configfile",
        default="/etc/minerva/link-entity-tags.conf",
        help="the path to the config file")

    parser.add_argument(
        "-v", "--verbose", action="store_true", default=False,
        help="verbose output")

    parser.add_argument(
        "-f", "--flush", action="store_true", default=False,
        help="flush current relations of specified type")

    parser.add_argument(
        "--generate-configfile", dest="generate_configfile",
        default=False, action="store_true", help="generate base config file")

    args = parser.parse_args()

    if args.generate_configfile:
        sys.stdout.write(CONFIG_DEFAULTS)
        return 0

    config = ConfigObj(StringIO(CONFIG_DEFAULTS))
    config.merge(ConfigObj(args.configfile))

    setup_logging(args.verbose)

    minerva_instance = MinervaInstance.load(args.instance)

    user = (args.user or config.get("database", {}).get("user")
            or "minerva_admin")

    module_directory = os.path.join(
        minerva_instance.minerva_class().path(), "tags/entity")

    sys.path.append(module_directory)

    module = __import__(args.tag_type)

    try:
        with closing(minerva_instance.connect(user=user)) as conn:
            link(conn, module, args.flush)
    except Exception:
        traceback.print_exc()
        return 1

    return 0


def link(conn, module, flush):
    tag_links = module.get_tag_links(conn)

    count = len(tag_links)

    get_tag_name = itemgetter(1)

    tag_names = set(map(get_tag_name, tag_links))

    for tag_name in tag_names:
        try:
            get_tag(conn, tag_name)
        except NoSuchTagError:

            tag_group = None
            if (hasattr(module, "GROUP_NAME")
                    and hasattr(module, "COMPLEMENTARY")):
                tag_group = create_tag_group(
                    conn, module.GROUP_NAME, module.COMPLEMENTARY)

            create_tag(conn, tag_name, tag_group)
        else:
            if flush:
                logging.info("flushing tags '{}'".format(tag_name))

                flush_tag_links(conn, tag_name)

    logging.info("storing {} tags".format(count))

    tag_entities(conn, tag_links)


def setup_logging(verbose):
    root_logger = logging.getLogger("")

    if verbose:
        handler = logging.StreamHandler(sys.stdout)

        root_logger.addHandler(handler)

    root_logger.setLevel(logging.INFO)


if __name__ == "__main__":
    sys.exit(main())
