#!/usr/bin/python
"""Load tags from txt file."""
import sys
import os
import argparse
import traceback
import logging
from contextlib import closing

from configobj import ConfigObj

from minerva import __version__ as version
from minerva.instance import MinervaInstance
from minerva.db import connect
from minerva.directory.helpers import get_entitytype
from minerva.directory.tag import NoSuchTagError, tag_entities, \
    flush_tag_links, get_tag, create_tag_group, create_tag
from minerva.db.util import create_copy_from_file, create_temp_table, \
    drop_table

package_name = "minerva"
script_name = os.path.basename(__file__)
config_file = "{}.conf".format(script_name)


def main():
    parser = argparse.ArgumentParser(
        description="Load tags from file")

    parser.add_argument(
        "--version", action="version", version=version,
        help="display version information and exit")

    parser.add_argument(
        "-i", "--instance", help="name of the target minerva instance")

    parser.add_argument(
        "file", metavar="FILE", nargs='*',
        help="file containing entity aliases used for tagging")

    parser.add_argument(
        "-t", "--entity-type", default="cell",
        help="name of the entity type (default 'cell')")

    parser.add_argument(
        "-a", "--alias-type", default="name",
        help="name of alias type (default 'name')")

    parser.add_argument(
        "-c", "--configfile", dest="configfile",
        default="/etc/minerva/load_tags.conf",
        help="the path to the config file")

    parser.add_argument(
        "-f", "--flush", action="store_true", default=False,
        help="flush current tags with specified name")

    parser.add_argument("-u", "--user", help="user to connect to database")

    args = parser.parse_args()

    minerva_instance = MinervaInstance.load(
        args.instance or
        os.environ.get("DEFAULT_MINERVA_INSTANCE") or
        "default"
    )

    config = ConfigObj(args.configfile)

    setup_logging()

    user = (
        args.user or
        config.get("database", {}).get("user") or
        "minerva_admin"
    )

    try:
        with closing(minerva_instance.connect(user=user)) as conn:
            entitytype = get_entitytype(conn, args.entity_type)

            for file_path in args.file:
                load_tags(conn, entitytype, args.alias_type, file_path,
                          args.flush)
    except Exception:
        traceback.print_exc()
        return 1

    return 0


def load_tags(conn, entitytype, alias_type_name, file_path, flush):
    _directory, file_name = os.path.split(file_path)
    name, _ext = os.path.splitext(file_name)

    logging.info("loading '{}' tags with name '{}' from {}".format(
        entitytype.name, name, file_path))

    try:
        get_tag(conn, name)
    except NoSuchTagError:
        tag_group = create_tag_group(
            conn, "default", False)

        create_tag(conn, name, tag_group)
        logging.info("created tag '{}'".format(name))
    else:
        if flush:
            logging.info("flushing tag '{}'".format(name))

            flush_tag_links(conn, name)

    with open(file_path, 'r') as tags_file:
        aliases = [line.rstrip() for line in tags_file]

    unique_aliases = list(set(aliases))

    entity_ids = aliases_to_entity_ids(conn, unique_aliases, "name", "Cell")

    tags = [(entity_id, name) for entity_id in entity_ids]

    tag_entities(conn, tags)

    conn.commit()


def aliases_to_entity_ids(conn, aliases, aliastype_name, entitytype_name):
    tmp_table_name = store_aliases_in_temp_table(conn, [(a,)for a in aliases])

    query = (
        "SELECT a.entity_id FROM {} tmp "
        "JOIN directory.alias a ON a.name = tmp.alias "
        "JOIN directory.aliastype at ON at.id = a.type_id "
        "JOIN directory.entity e ON e.id = a.entity_id "
        "JOIN directory.entitytype et ON et.id = e.entitytype_id "
        "WHERE at.name = %s AND et.name = %s").format(tmp_table_name)

    args = (aliastype_name, entitytype_name)

    with closing(conn.cursor()) as cursor:
        cursor.execute(query, args)

        rows = cursor.fetchall()

    drop_table(conn, tmp_table_name)

    return [entity_id for entity_id, in rows]


def store_aliases_in_temp_table(conn, aliases):
    tmp_table_name = "tmp_aliases"
    columns = [
        ("alias", "varchar"),
    ]
    column_names = [col_name for col_name, col_type in columns]
    sql_columns = ["{} {}".format(*column) for column in columns]

    copy_from_file = create_copy_from_file(aliases, ('s',))
    create_temp_table(conn, tmp_table_name, sql_columns)

    with closing(conn.cursor()) as cursor:
        cursor.copy_from(copy_from_file, tmp_table_name, columns=column_names)

    return tmp_table_name


def setup_logging():
    handler = logging.StreamHandler(sys.stdout)

    logging.root.addHandler(handler)

    logging.root.setLevel(logging.INFO)


if __name__ == "__main__":
    sys.exit(main())
