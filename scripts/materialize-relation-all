#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import argparse
import logging
from contextlib import closing

from minerva import __version__ as version
from minerva.util.config import load_config, get_defaults, ConfigError
from minerva.instance import MinervaInstance
from minerva.storage import get_plugin
from minerva.storage.geospatial.types import Site, Cell, Point


package_name = "minerva"
script_name = os.path.basename(__file__)
config_file = "{}.conf".format(script_name)


def main():
    default_minerva_instance = os.environ.get(
        "DEFAULT_MINERVA_INSTANCE", "default")

    config_file_path = os.path.join("/etc/minerva", config_file)

    parser = argparse.ArgumentParser(
        description="Populate relation.all_materialized")

    parser.add_argument(
        "--version", action="version", version=version,
        help="display version information and exit")

    parser.add_argument(
        "-i", "--instance", default=default_minerva_instance,
        help="name of the target minerva instance")

    parser.add_argument("-u", "--user", help="user to connect to database")

    parser.add_argument(
        "-c", "--configfile", dest="configfile", default=config_file_path,
        help="the path to the config file")

    parser.add_argument(
        "-v", "--verbose", action="store_true", default=False,
        help="verbose output")

    parser.add_argument(
        "-d", "--debug", action="store_true", default=False,
        help="debug output")

    parser.add_argument(
        "--generate-configfile", dest="generate_configfile",
        action=GenerateConfigFileAction, nargs=0,
        help="generate base config file")

    args = parser.parse_args()

    try:
        config = load_config(get_defaults(package_name, config_file),
                             args.configfile)
    except ConfigError as exc:
        print("error loading configuration: {}".format(exc))
        return 1

    minerva_instance = MinervaInstance.load(args.instance)
    user = (args.user or config.get("database", {}).get("user")
        or "minerva_admin")

    if args.verbose or args.debug:
        if args.debug:
            setup_logging(logging.DEBUG)
        else:
            setup_logging(logging.INFO)

    with closing(minerva_instance.connect(user=user)) as conn:
        drop_if_exists(conn, "relation.all_materialized_temp")
        create_temporary_table(conn)
        materialize(conn)
        drop_if_exists(conn, "relation.all_materialized")
        rename_temporary_table(conn)

    return 0


def setup_logging(level):
    root_logger = logging.getLogger("")

    root_logger.addHandler(logging.StreamHandler())
    root_logger.setLevel(level)


def create_temporary_table(conn):
    query = """
CREATE TABLE relation.all_materialized_temp
(
  source_id integer NOT NULL,
  target_id integer NOT NULL,
  type_id integer NOT NULL,
  CONSTRAINT all_materialized_temp_pkey PRIMARY KEY (source_id, target_id, type_id)
)
WITH (
  OIDS=FALSE
);
ALTER TABLE relation.all_materialized_temp OWNER TO minerva_admin;
GRANT ALL ON TABLE relation.all_materialized_temp TO minerva_admin;
GRANT SELECT ON TABLE relation.all_materialized_temp TO minerva;
GRANT UPDATE, INSERT, DELETE ON TABLE relation.all_materialized_temp TO minerva_writer;
CREATE INDEX all_materialized_temp_target_id_idx ON relation.all_materialized_temp USING btree (target_id);
CREATE INDEX all_materialized_temp_type_id_idx ON relation.all_materialized_temp USING btree (type_id);
"""
    with closing(conn.cursor()) as cursor:
        cursor.execute(query)
    
    conn.commit()


def rename_temporary_table(conn):
    query = """
ALTER TABLE relation.all_materialized_temp RENAME TO all_materialized;
ALTER INDEX relation.all_materialized_temp_pkey RENAME TO all_materialized_pkey;
ALTER INDEX relation.all_materialized_temp_target_id_idx RENAME TO all_materialized_target_id_idx;
ALTER INDEX relation.all_materialized_temp_type_id_idx RENAME TO all_materialized_type_id_idx;
"""

    with closing(conn.cursor()) as cursor:
        cursor.execute(query)
    
    conn.commit()


def table_exists(conn, tablename):
    values = tablename.split(".")
    if len(values) == 1:
        s = "public"
        t = values[0]
    elif len(values) > 1:
        s = values[0]
        t = ".".join(values[1:])
    else:
        return False
    
    query = """
SELECT EXISTS( SELECT * FROM information_schema.tables 
WHERE table_schema = %s AND table_name = %s)"""

    with closing(conn.cursor()) as cursor:
        cursor.execute(query, (s, t))
        exist, = cursor.fetchone()
    
    return exist


def drop_if_exists(conn, tablename):
    if table_exists(conn, tablename):
        query = "DROP TABLE {}".format(tablename)
        with closing(conn.cursor()) as cursor:
            cursor.execute(query)
        conn.commit()


def materialize(conn):
    query = "INSERT INTO relation.all_materialized_temp SELECT * FROM relation.all" 
    
    with closing(conn.cursor()) as cursor:
        cursor.execute(query)
    
    conn.commit()



class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(get_defaults(package_name, config_file))
        sys.exit(0)


if __name__ == "__main__":
    main()
