#!/usr/bin/python
"""Command line tool to load data packages."""
import sys
import os
import argparse
from contextlib import closing
from functools import partial

from minerva.util import k
from minerva.directory.helpers_v4 import name_to_datasource, \
    get_entity_by_id, get_entitytype_by_id
from minerva.instance import MinervaInstance
from minerva.storage import load_plugins


def main():
    """Script entrypoint."""
    default_instance_name = os.environ.get("DEFAULT_MINERVA_INSTANCE",
                                           "default")

    parser = argparse.ArgumentParser(
        description="Load data package")

    parser.add_argument(
        "files", nargs="*", help="files with data packages")

    parser.add_argument(
        "-i", "--instance", default=default_instance_name,
        help="name of the target minerva instance")

    parser.add_argument(
        "-u", "--user", default="minerva_admin",
        help="user to connect to database")

    parser.add_argument(
        "-c", "--storage-class", default="trend",
        help="storage class to use for the data package")

    parser.add_argument(
        "--store", action="store_true", default=False,
        help="actually store the data in the database")

    parser.add_argument(
        "--raw", action="store_true", default=False,
        help="datapackage is raw package with distinguished names")

    parser.add_argument(
        "--datasource", default="load-datapackage",
        help="name of datasource to use for storing the data")

    parser.add_argument(
        "--deduce-datatypes", default=False, action="store_true",
        help="deduce the data types from the data in the package")

    args = parser.parse_args()

    minerva_instance = MinervaInstance.load(args.instance)

    storage_plugins = load_plugins()

    try:
        storage_plugin = storage_plugins[args.storage_class]
    except KeyError:
        print("No such storage class: '{}'".format(args.storage_class))
        return 1

    with closing(minerva_instance.connect(user=args.user)) as conn:
        with closing(conn.cursor()) as cursor:
            datasource = name_to_datasource(cursor, args.datasource)

        storage_class = storage_plugin(conn, api_version=4)

        file_handles = make_file_handles(args.files)

        for file_handle in file_handles:
            with file_handle() as package_file:
                if args.raw:
                    datapackage = storage_class.load_rawdatapackage(
                        package_file)
                else:
                    datapackage = storage_class.load_datapackage(package_file)

                if args.deduce_datatypes:
                    print(datapackage.deduce_attributes())

                if args.store:
                    if args.raw:
                        storage_class.store_raw(datasource, datapackage)
                    else:
                        with closing(conn.cursor()) as cursor:
                            entity = get_entity_by_id(cursor, datapackage.rows[0][0])
                            entitytype = get_entitytype_by_id(cursor, entity.entitytype_id)

                        storage_class.store(datasource, entitytype, datapackage)

    return 0


def make_file_handles(files):
    if files:
        return [partial(open, file_name, 'r') for file_name in files]
    else:
        return k(sys.stdin)


if __name__ == "__main__":
    sys.exit(main())
