#!/usr/bin/python
"""
Creates csv output based on modules found in module_directory
"""
import sys
import os
import argparse
import traceback
import logging
from datetime import datetime
from functools import partial
from contextlib import closing
from logging.handlers import RotatingFileHandler
import pytz

import psycopg2.errorcodes
import psycopg2.extras

from minerva.db import parse_db_url

from minerva.util.config import parse_size, load_config, get_defaults, \
    ConfigError

package_name = "minerva"
script_name = os.path.basename(__file__)
config_file = "{}.conf".format(script_name)

LEVEL_MAP = {
    "DEBUG": logging.DEBUG,
    "INFO": logging.INFO,
    "WARNING": logging.WARNING,
    "ERROR": logging.ERROR,
    "CRITICAL": logging.CRITICAL}


def setup_args_parser():
    parser = argparse.ArgumentParser(description="Create virtual entities")

    parser.add_argument(
        "-m", "--module",
        help="name of the module containing output generation magic")

    parser.add_argument(
        "-c", "--configfile", dest="configfile",
        default="/etc/minerva/create-csv.conf",
        help="the path to the config file")

    parser.add_argument(
        "-t", "--timestamp", help="Timestamp specifying data to "
        "process (%%Y%%m%%d_%%H%%M%%S). When ommitted now() is used.")

    parser.add_argument(
        "-v", "--verbose", action="store_true", default=False,
        help="verbose output")

    parser.add_argument(
        "--debug", action="store_true", default=False,
        help="log and show debug output")

    parser.add_argument(
        "-p", "--pretend", action="store_true", default=False,
        help="determine relations, but don't store anything in database")

    parser.add_argument(
        "-f", "--to-file", action="store_true", default=False,
        help="store output to file")

    parser.add_argument(
        "--generate-configfile", dest="generate_configfile",
        action=GenerateConfigFileAction, nargs=0,
        help="generate base config file")

    return parser.parse_args()


def main():
    args = setup_args_parser()

    if args.generate_configfile:
        print(CONFIG_DEFAULTS)
        return 0

    try:
        config = load_config(get_defaults(package_name, config_file), args.configfile)
    except ConfigError as exc:
        print("error loading configuration: {}".format(exc))
        return 1

    log_level = LEVEL_MAP[config["logging"]["level"]]

    if args.debug:
        log_level = logging.DEBUG

    logger = setup_file_logging(
        config["logging"]["directory"],
        config["logging"]["base_name"],
        config["logging"]["rotation_size"],
        log_level)

    if args.verbose or args.debug:
        enable_console_logging(logger)

    if log_level == logging.DEBUG:
        connection_logger = logging.getLogger("connection")
    else:
        connection_logger = None

    tz = pytz.timezone("Europe/Amsterdam")
    if args.timestamp is None:
        ts = datetime.now()
    else:
        ts = datetime.strptime(args.timestamp, "%Y%m%d_%H%M%S")
    ts = tz.localize(ts)

    if args.module is None:
        print("no module specified")
        return 2

    sys.path.append(config["module_directory"])
    module = __import__(args.module)
    try:
        logging.info("processing create-csv module : '{}'".format(args.module))

        if args.to_file:
            out = open(os.path.join(config["output_directory"], module.file_name(ts)), 'wb')
        else:
            out = sys.stdout

        with closing(connect(config["database"]["uri"], connection_logger)) as conn:
            records = module.records(conn, ts)

        sep_char = config["sep_char"]

        with closing(out) as f:
            f.write(sep_char.join(module.fields(conn, ts)))
            f.write("\n")
            for record in records:
                f.write(sep_char.join(map(str,record)))
                f.write("\n")

    except Exception:
        traceback.print_exc()
        return 1

    return 0


def enable_console_logging(logger):
    handler = logging.StreamHandler(sys.stdout)

    logger.addHandler(handler)


def setup_file_logging(directory, filename, rotation_size, level):
    """
    Setup rotating file logging.
    """
    max_log_size = parse_size(rotation_size)

    filepath = os.path.join(directory, filename)
    handler = RotatingFileHandler(filepath, maxBytes=max_log_size, backupCount=5)
    handler.setLevel(level)

    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    handler.setFormatter(formatter)

    rootlogger = logging.getLogger("")
    rootlogger.setLevel(level)
    rootlogger.addHandler(handler)
    return rootlogger


def connect(db_url, logger=None):
    scheme, user, password, host, port, database = parse_db_url(db_url)

    assert scheme == "postgresql", "Only PostgreSQL connections are supported"

    create_connection = partial(psycopg2.connect, database=database, user=user,
            password=password, host=host, port=port)

    if logger:
        conn = create_connection(connection_factory=psycopg2.extras.LoggingConnection)

        conn.initialize(logger)
    else:
        conn = create_connection()

    return conn


class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(get_defaults(package_name, config_file))
        sys.exit(0)


if __name__ == "__main__":
    sys.exit(main())
