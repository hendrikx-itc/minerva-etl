#!/usr/bin/env python
# -*- coding: utf-8 -*-
__docformat__ = "restructuredtext en"

__copyright__ = """
Copyright (C) 2008-2013 Hendrikx-ITC B.V.

Distributed under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option) any later
version.  The full license is in the file COPYING, distributed as part of
this software.
"""
import os
import sys
import argparse
import logging
from operator import itemgetter
from contextlib import closing
import traceback
import datetime
from functools import partial

import psycopg2.extras

from minerva.db import parse_db_url, extract_safe_url
from minerva.util.config import load_config, get_defaults, ConfigError
from minerva.directory.helpers import get_datasource, get_entitytype

from minerva_storage_trend.tables import resolve_table_name, InvalidTrendTableName, PARTITION_SIZES
from minerva_storage_trend.types_v4 import Partition, TrendStore
from minerva_storage_trend.inference import populate, extract_partitions

package_name = "minerva_storage_trend"
script_name = os.path.basename(__file__)
config_file = "{}.conf".format(script_name)


def main():
    config_file_path = os.path.join("/etc/minerva", config_file)

    parser = argparse.ArgumentParser(
        description="Edit partitions")

    parser.add_argument("table_names", metavar="TABLES", nargs='*',
        help="tables to process, if none specified, all tables will be processed")

    parser.add_argument("-c", "--configfile", dest="configfile",
        default=config_file_path, help="the path to the config file")

    parser.add_argument("-v", "--verbose", action="store_true", default=False,
        help="verbose output")

    parser.add_argument("-l", "--list", action="store_true", default=False,
        help="list available partitions")

    parser.add_argument("--generate-configfile", dest="generate_configfile",
        action=GenerateConfigFileAction, nargs=0, help="generate base config file")

    root_logger = logging.getLogger("")
    handler = logging.StreamHandler(sys.stdout)
    root_logger.addHandler(handler)

    args = parser.parse_args()

    try:
        config = load_config(get_defaults(package_name, config_file), args.configfile)
    except ConfigError as exc:
        logging.error("error loading configuration: {}".format(exc))
        return 1

    if args.verbose:
        root_logger.setLevel(logging.DEBUG)
        
        create_connection = partial(connect, config["db_url"], root_logger)
    else:
        root_logger.setLevel(logging.INFO)

        create_connection = partial(connect, config["db_url"])

    with closing(create_connection()) as conn:
        with closing(conn.cursor()) as cursor:
            if args.list:
                logging.info("Available partitions:")

                partitions = extract_partitions(cursor)

                for partition in partitions:
                    logging.info("-- {}".format(partition.name))
            else:
                    populate(cursor, args.table_names)

        conn.commit()

    return 0


def connect(db_url, logger=None):
    scheme, user, password, host, port, database = parse_db_url(db_url)

    assert scheme == "postgresql", "Only PostgreSQL connections are supported"

    create_connection = partial(psycopg2.connect, database=database, user=user,
            password=password, host=host, port=port)

    if logger:
        conn = create_connection(connection_factory=psycopg2.extras.LoggingConnection)

        conn.initialize(logger)
    else:
        conn = create_connection()

    return conn


class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(get_defaults(package_name, config_file))
        sys.exit(0)


if __name__ == "__main__":
    main()
