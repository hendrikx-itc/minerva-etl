#!/usr/bin/python
# -*- coding: utf-8 -*-
__docformat__ = "restructuredtext en"

__copyright__ = """
Copyright (C) 2008-2012 Hendrikx-ITC B.V.

Distributed under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option) any later
version.  The full license is in the file COPYING, distributed as part of
this software.
"""
import sys
import os
from datetime import datetime

import pytz
import logging.handlers
from argparse import ArgumentParser, Action
from contextlib import closing
from configobj import ConfigObj
import csv

from minerva.util import parse_size
from minerva.util.config import load_config, get_defaults, ConfigError
from minerva.directory.helpers import get_datasource, \
    NoSuchDataSourceError
from minerva.db import connect
from minerva.storage.trend.plugin import TrendPlugin


package_name = "minerva"
script_name = os.path.basename(__file__)
config_file = "{}.conf".format(script_name)


def setup_logging(directory, filename, rotation_size, level, verbose, quiet):
    level_map = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL}

    max_log_size = parse_size(rotation_size)

    filepath = os.path.join(directory, filename)
    handler = logging.handlers.RotatingFileHandler(filepath, maxBytes=max_log_size,
            backupCount=5)
    handler.setLevel(level_map[level])

    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    handler.setFormatter(formatter)

    rootlogger = logging.getLogger("")
    rootlogger.setLevel(level_map[level])
    rootlogger.addHandler(handler)

    if not quiet:
        stream_handler = logging.StreamHandler()
        stream_handler.setFormatter(formatter)
        if verbose:
            stream_handler.setLevel(logging.DEBUG)
        else:
            stream_handler.setLevel(logging.WARNING)

        rootlogger.addHandler(stream_handler)


def main():
    config_file_path = os.path.join("/etc/minerva", config_file)

    parser = ArgumentParser(
        description = "Script for exporting specific trend data")

    parser.add_argument("datasource",
        help="data source of trend data to export")

    parser.add_argument("entitytype",
        help="entity type (e.g UtranCell, Cell, BTS)")

    parser.add_argument("granularity",
        help="granularity of trend data in seconds")

    parser.add_argument("start",
        help="start of interval to export [YYYYmmdd_HHMMSS]")
    parser.add_argument("end",
        help="end of interval to export [YYYYmmdd_HHMMSS]")

    parser.add_argument("-c", "--configfile", dest="configfile",
        default=config_file_path, help="path to config file")
    parser.add_argument("--generate-configfile",
        action=GenerateConfigFileAction, nargs=0,
            help="generate base config file and exit")
    parser.add_argument("-v", "--verbose", action="store_true", dest="verbose",
        default=False, help="Produce verbose output")
    parser.add_argument("-q", "--quiet", action="store_true", dest="quiet",
        default=False, help="Produce output to log file")
    parser.add_argument("--timezone", dest="timezone", default="Europe/Amsterdam",
        help="timezone of data timestamps")
    parser.add_argument("--trends", dest="trends", default=[],
        nargs="+", help="Trends to export.")

    args = parser.parse_args()

    try:
        config = load_config(get_defaults(package_name, config_file), args.configfile)
    except ConfigError as exc:
        print("error loading configuration: {}".format(exc))
        return 1

    try:
        start = pytz.timezone(args.timezone).localize(
            datetime.strptime(args.start, "%Y%m%d_%H%M%S"))
    except TypeError:
        print("Error: invalid 'start' timestamp")
        return 1

    try:
        end = pytz.timezone(args.timezone).localize(
            datetime.strptime(args.end, "%Y%m%d_%H%M%S"))
    except TypeError:
        print("Error: invalid 'end' timestamp")
        return 1

    config = ConfigObj(args.configfile)

    setup_logging(config["log_directory"], config["log_filename"],
        config["log_rotation_size"], config["log_level"], args.verbose, args.quiet)

    logging.root.setLevel(config["log_level"])

    with closing(connect(config["db_uri"])) as conn:

        plugin = TrendPlugin(conn)

        try:
            ds = get_datasource(conn, args.datasource)
        except NoSuchDataSourceError:
            print("Unknown datasource '{0}'".format(args.datasource))
            return 1

        rows = plugin.retrieve([ds], int(args.granularity), args.entitytype,
            args.trends, None, start, end)

        header = ["entity_id", "timestamp"] + args.trends

        dialect = csv.Dialect
        dialect.delimiter = config["csv_delimiter"]
        dialect.lineterminator = '\n'
        dialect.quotechar = config["csv_quotechar"]
        dialect.quoting = csv.QUOTE_NONE

        writer = csv.writer(sys.stdout, dialect=dialect)
        writer.writerow(header)
        writer.writerows(rows)

    return 0


class GenerateConfigFileAction(Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(get_defaults(package_name, config_file))
        sys.exit(0)


if __name__ == "__main__":
    sys.exit(main())
