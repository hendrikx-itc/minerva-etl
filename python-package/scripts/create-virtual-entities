#!/usr/bin/python
"""Create virtual entities based on modules found in module_directory."""
import sys
import os
import argparse
import traceback
import logging
from contextlib import closing
from logging.handlers import RotatingFileHandler

from minerva import __version__ as version
from minerva.db import connect

from minerva.directory import create_entity
from minerva.util.config import load_config, get_defaults, ConfigError, \
    parse_size

package_name = "minerva"
script_name = os.path.basename(__file__)
config_file = "{}.conf".format(script_name)


def setup_args_parser():
    config_file_path = os.path.join("/etc/minerva", config_file)

    parser = argparse.ArgumentParser(description="Create virtual entities")

    parser.add_argument(
        "--version", action="version", version=version,
        help="display version information and exit")

    parser.add_argument(
        "-e", "--virtual-entity",
        help="name of the module containing the Virtual Entities")

    parser.add_argument(
        "-c", "--configfile", dest="configfile",
        default=config_file_path, help="the path to the config file")

    parser.add_argument(
        "-v", "--verbose", action="store_true", default=False,
        help="verbose output")

    parser.add_argument(
        "-p", "--pretend", action="store_true", default=False,
        help="determine relations, but don't store anything in database")

    parser.add_argument(
        "--generate-configfile", dest="generate_configfile",
        action=GenerateConfigFileAction, nargs=0,
        help="generate base config file")

    return parser


def main():
    parser = setup_args_parser()
    args = parser.parse_args()

    config_defaults = get_defaults(package_name, config_file)

    if args.generate_configfile:
        print(config_defaults)
        return 0

    try:
        config = load_config(config_defaults, args.configfile)
    except ConfigError as exc:
        print("error loading configuration: {}".format(exc))
        return 1

    setup_logging(args.verbose)
    setup_file_logging(
        config["log_directory"], config["log_filename"],
        config["log_rotation_size"], config["log_level"])

    if args.virtual_entity is None:
        print("no virtual entity specified")
        return 2

    sys.path.append(config["module_directory"])
    module = __import__(args.virtual_entity)
    try:
        logging.info("generating virtual_entities: '{}'".format(
            args.virtual_entity))

        with closing(connect(config["db_uri"])) as conn:
            generate_virtual_entities(conn, module.get_virtual_entities)
            conn.commit()

    except Exception:
        traceback.print_exc()
        return 1

    return 0


def generate_virtual_entities(conn, generator):
    entities = generator(conn)

    count = len(entities)
    logging.info("storing {} virtual_entities".format(count))

    for entity_dn, in entities:
        create_entity(conn, entity_dn)


def setup_logging(verbose):
    root_logger = logging.getLogger("")

    if verbose:
        handler = logging.StreamHandler(sys.stdout)

        root_logger.addHandler(handler)

    root_logger.setLevel(logging.INFO)


def setup_file_logging(directory, filename, rotation_size, level):
    """Setup rotating file logging."""
    level_map = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL}

    max_log_size = parse_size(rotation_size)

    filepath = os.path.join(directory, filename)
    handler = RotatingFileHandler(filepath, maxBytes=max_log_size,
                                  backupCount=5)
    handler.setLevel(level_map[level])

    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    handler.setFormatter(formatter)

    rootlogger = logging.getLogger("")
    rootlogger.setLevel(level_map[level])
    rootlogger.addHandler(handler)


class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(get_defaults(package_name, config_file))
        sys.exit(0)


if __name__ == "__main__":
    sys.exit(main())
