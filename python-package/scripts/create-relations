#!/usr/bin/python
"""
Creates relations between entities
"""
import sys
import os
import re
import argparse
import traceback
import logging
from contextlib import closing
from logging.handlers import RotatingFileHandler
from pkg_resources import resource_string
from StringIO import StringIO

import psycopg2.extras
from configobj import ConfigObj

from minerva.instance import MinervaInstance
from minerva.directory.relation import add_relations, flush_relations, \
    reverse_relations
from minerva.util.config import parse_size


CONFIG_DEFAULTS = resource_string("minerva", "defaults/create-relations.conf")

type_regex = re.compile(r"(.*)->(.*)")

NORMAL = 1
REVERSE = 2
BIDIRECTIONAL = 3

LEVEL_MAP = {
    "DEBUG": logging.DEBUG,
    "INFO": logging.INFO,
    "WARNING": logging.WARNING,
    "ERROR": logging.ERROR,
    "CRITICAL": logging.CRITICAL}


def main():
    default_minerva_instance = os.environ.get(
        "DEFAULT_MINERVA_INSTANCE", "default")

    parser = argparse.ArgumentParser(
        description="Create relations between entities")

    parser.add_argument(
        "-i", "--instance", default=default_minerva_instance,
        help="name of the target minerva instance")

    parser.add_argument("-u", "--user", help="user to connect to database")

    parser.add_argument(
        "-t", "--relation-type",
        help="name of the module containing the relation type definition")

    parser.add_argument(
        "-c", "--configfile", dest="configfile",
        default="/etc/minerva/create-relations.conf",
        help="the path to the config file")

    parser.add_argument(
        "-v", "--verbose", action="store_true", default=False,
        help="verbose output")

    parser.add_argument(
        "--debug", action="store_true", default=False,
        help="output for debugging purposes")

    parser.add_argument(
        "-f", "--flush", action="store_true", default=False,
        help="flush current relations of specified type")

    parser.add_argument(
        "-p", "--pretend", action="store_true", default=False,
        help="determine relations, but don't store anything in database")

    parser.add_argument(
        "-r", "--reverse", action="store_true", default=False,
        help="generate reverse relations")

    parser.add_argument(
        "-b", "--bi-directional", action="store_true", default=False,
        help="generate bi-directional relations")

    parser.add_argument(
        "--generate-configfile", dest="generate_configfile",
        action=GenerateConfigFileAction, nargs=0,
        help="generate base config file")

    args = parser.parse_args()

    if args.generate_configfile:
        print(CONFIG_DEFAULTS)
        return 0

    minerva_instance = MinervaInstance.load(args.instance)

    config = ConfigObj(StringIO(CONFIG_DEFAULTS))
    config.merge(ConfigObj(args.configfile))

    user = (
        args.user or
        config.get("database", {}).get("user") or
        "minerva_admin")

    log_level = LEVEL_MAP[config["log_level"]]

    if args.debug:
        log_level = logging.DEBUG

    setup_logging(log_level)

    setup_file_logging(config["log_directory"], config["log_filename"],
                       config["log_rotation_size"], log_level)

    mode = NORMAL
    if args.reverse:
        mode = REVERSE
    if args.bi_directional:
        mode = BIDIRECTIONAL

    module_directory = os.path.join(minerva_instance.minerva_class().path(),
                                    "relations")

    sys.path.append(module_directory)

    module = __import__(args.relation_type)

    try:
        cardinality = module.RELATIONTYPE_CARDINALITY
    except AttributeError:
        cardinality = None

    if args.relation_type is None:
        print("no type specified")
        return 2

    try:
        with closing(minerva_instance.connect(user=user)) as conn:
            if hasattr(module, "get_relationtypes"):
                for relationtype_name, generator in module.get_relationtypes(conn):
                    generate_relations(
                        conn, relationtype_name, cardinality, generator, mode,
                        args.flush)
            else:
                generate_relations(conn, module.RELATIONTYPE_NAME,
                                   cardinality, module.get_relations, mode,
                                   args.flush)

            conn.commit()
    except Exception:
        traceback.print_exc()
        return 1

    return 0


def generate_relations(conn, relationtype_name, relationtype_cardinality,
                       generator, mode, flush):
    match = type_regex.match(relationtype_name)

    if not match is None:
        type_names = match.groups()

        source_type_name, target_type_name = type_names

        reverseable = True
    else:
        reverseable = False

    logging.info("generating relations of type '{}'".format(relationtype_name))

    relations = generator(conn)

    count = len(relations)

    if mode == NORMAL or mode == BIDIRECTIONAL:
        if flush:
            logging.info("flushing relations of type '{}'".format(
                relationtype_name))

            try:
                flush_relations(conn, relationtype_name)
            except psycopg2.ProgrammingError as e:
                conn.rollback()
                if e.pgcode == psycopg2.errorcodes.UNDEFINED_TABLE:
                    logging.info("Flush failed since {}.".format(e))
                else:
                    raise

        logging.info(
            "storing {} relations of type '{}' cardinality '{}'".format(
                count, relationtype_name, relationtype_cardinality))

        add_relations(conn, relations, relationtype_name,
                      relationtype_cardinality)
        conn.commit()

    if reverseable and (mode == REVERSE or mode == BIDIRECTIONAL):
        relationtype_name = "{}->{}".format(target_type_name, source_type_name)
        relationtype_cardinality = reverse_cardinality(
            relationtype_cardinality)

        if flush:
            logging.info("flushing relations of type '{}'".format(
                relationtype_name))

            try:
                flush_relations(conn, relationtype_name)
            except psycopg2.ProgrammingError as e:
                conn.rollback()
                if e.pgcode == psycopg2.errorcodes.UNDEFINED_TABLE:
                    logging.info("Flush failed since {}.".format(e))
                else:
                    raise

        logging.info("storing {} relations of type '{}' cardinality '{}'".format(count, relationtype_name, relationtype_cardinality))

        add_relations(conn, reverse_relations(relations), relationtype_name, relationtype_cardinality)
        conn.commit()


def reverse_cardinality(cardinality_type):
    if cardinality_type == 'one-to-many':
        return 'many-to-one'
    if cardinality_type == 'many-to-one':
        return 'one-to-many'

    return cardinality_type


def setup_logging(level):
    root_logger = logging.getLogger("")

    if level in (logging.INFO, logging.DEBUG):
        handler = logging.StreamHandler(sys.stdout)

        root_logger.addHandler(handler)

    root_logger.setLevel(logging.INFO)


def setup_file_logging(directory, filename, rotation_size, level):
    """
    Setup rotating file logging.
    """
    max_log_size = parse_size(rotation_size)

    filepath = os.path.join(directory, filename)
    handler = RotatingFileHandler(filepath, maxBytes=max_log_size, backupCount=5)
    handler.setLevel(level)

    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    handler.setFormatter(formatter)

    rootlogger = logging.getLogger("")
    rootlogger.setLevel(level)
    rootlogger.addHandler(handler)


class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(CONFIG_DEFAULTS)
        sys.exit(0)


if __name__ == "__main__":
    sys.exit(main())
