#!/usr/bin/python
# -*- coding: utf-8 -*-
import os
import sys
import argparse
import logging
from contextlib import closing
from functools import partial
import json
import pprint

import psycopg2.extras
import yaml

from minerva.util import unlines, expand_args
from minerva.util.config import load_config, get_defaults, ConfigError
from minerva.db import parse_db_url

version = "3.0.0"

package_name = "minerva"
script_name = os.path.basename(__file__)
config_file = "{}.conf".format(script_name)

class JobInfo(object):
    def __init__(self, job_id, type, state, description):
        self.id = job_id
        self.type = type
        self.state = state
        self.description = description

    def show(self):
        description_dict = json.loads(self.description)

        description_yaml = yaml.safe_dump(description_dict)

        report = [
            "--- Job {} ---".format(self.id),
            " type: {}".format(self.type),
            " state: {}".format(self.state),
            " description:\n{}".format(description_yaml)]

        return unlines(report)


def main():
    config_file_path = os.path.join("/etc/minerva/", config_file)

    parser = argparse.ArgumentParser(
            description="Execute transforming module(s) and store results in Minerva")

    parser.add_argument("--version", dest="show_version", default=False,
        action="store_true", help="display version information and exit")

    parser.add_argument("-c", "--configfile",
            default=config_file_path, help="path to config file")

    parser.add_argument("--generate-configfile",
            action=GenerateConfigFileAction, nargs=0, help="generate default config file")

    parser.add_argument("job", help="job Id", type=int)

    args = parser.parse_args()

    if args.show_version:
        print("minerva {0}".format(version))
        return 0

    try:
        config = load_config(get_defaults(package_name, config_file), args.configfile)
    except ConfigError as exc:
        print("error loading configuration: {}".format(exc))
        return 1

    job_id = args.job

    db_url = config["db_url"]

    logger = logging.getLogger("")

    with closing(connect(db_url, logger)) as conn:
        with closing(conn.cursor()) as cursor:
            query = (
                "SELECT id, type, state, description "
                "FROM system.job "
                "WHERE id = %s")

            args = job_id,

            cursor.execute(query, args)

            job_info = expand_args(JobInfo)(cursor.fetchone())

            query = "SELECT message FROM system.job_error_log WHERE job_id = %s"
            args = job_id,

            cursor.execute(query, args)

            error_message, = cursor.fetchone()

            print(job_info.show())

            print("\n-- error message ---\n{}".format(error_message))


def connect(db_url, logger=None):
    scheme, user, password, host, port, database = parse_db_url(db_url)

    assert scheme == "postgresql", "Only PostgreSQL connections are supported"

    create_connection = partial(psycopg2.connect, database=database, user=user,
            password=password, host=host, port=port)

    if logger:
        conn = create_connection(connection_factory=psycopg2.extras.LoggingConnection)

        conn.initialize(logger)
    else:
        conn = create_connection()

    return conn


class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(get_defaults(package_name, config_file))
        sys.exit(0)


if __name__ == "__main__":
    sys.exit(main())
