#!/usr/bin/env python
# -*- coding: utf-8 -*-
__docformat__ = "restructuredtext en"

__copyright__ = """
Copyright (C) 2008-2013 Hendrikx-ITC B.V.

Distributed under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option) any later
version.  The full license is in the file COPYING, distributed as part of
this software.
"""
import os
import sys
import argparse
import logging
from operator import itemgetter
from contextlib import closing
import traceback
import datetime
from functools import partial

import psycopg2.extras

from minerva.db import parse_db_url, extract_safe_url
from minerva.util.config import load_config, get_defaults, ConfigError
from minerva.util import first


package_name = "minerva"
script_name = os.path.basename(__file__)
config_file = "{}.conf".format(script_name)


def main():
    config_file_path = os.path.join("/etc/minerva", config_file)

    parser = argparse.ArgumentParser(description="Cleanup trend data")

    parser.add_argument("-c", "--configfile", dest="configfile",
            default=config_file_path, help="the path to the config file")

    parser.add_argument("-v", "--verbose", action="store_true", default=False,
            help="verbose output")

    parser.add_argument("--pretend", action="store_true", default=False,
            help="don't really delete partitions")

    parser.add_argument("-g", "--granularity", default="900",
            help="granularity of trendstores to clean")

    parser.add_argument("-a", "--age", default="14 days",
            help="minimum age of partitions to remove")

    parser.add_argument("--generate-configfile", dest="generate_configfile",
            action=GenerateConfigFileAction, nargs=0, help="generate base config file")

    root_logger = logging.getLogger("")
    handler = logging.StreamHandler(sys.stdout)
    root_logger.addHandler(handler)

    args = parser.parse_args()

    try:
        config = load_config(get_defaults(package_name, config_file), args.configfile)
    except ConfigError as exc:
        logging.error("error loading configuration: {}".format(exc))
        return 1

    if args.verbose:
        root_logger.setLevel(logging.DEBUG)

        create_connection = partial(connect, config["db_uri"], root_logger)
    else:
        root_logger.setLevel(logging.INFO)

        create_connection = partial(connect, config["db_uri"])

    select_query = (
        "SELECT table_name, data_start, data_end "
        "FROM trend.partition p "
        "JOIN trend.trendstore ts ON ts.id = p.trendstore_id "
        "WHERE ts.granularity = %s AND data_end < now() - interval %s "
        "ORDER BY data_end, table_name")

    select_args = args.granularity, args.age

    delete_query = (
        "DELETE FROM trend.partition "
        "WHERE table_name = %s")

    with closing(create_connection()) as conn:
        with closing(conn.cursor()) as cursor:
            cursor.execute(select_query, select_args)

            for table_name, start, end in cursor.fetchall():
                if not args.pretend:
                    cursor.execute(delete_query, (table_name,))
                    conn.commit()
                logging.info("dropped table {}, {} - {}".format(table_name, start, end))

    return 0


def connect(db_url, logger=None):
    scheme, user, password, host, port, database = parse_db_url(db_url)

    assert scheme == "postgresql", "Only PostgreSQL connections are supported"

    create_connection = partial(psycopg2.connect, database=database, user=user,
            password=password, host=host, port=port)

    if logger:
        conn = create_connection(connection_factory=psycopg2.extras.LoggingConnection)

        conn.initialize(logger)
    else:
        conn = create_connection()

    return conn


class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(get_defaults(package_name, config_file))
        sys.exit(0)


if __name__ == "__main__":
    main()
