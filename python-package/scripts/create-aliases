#!/usr/bin/python
"""
Creates aliased based on modules found in module_directory
"""
import sys
import os
import re
import argparse
import traceback
import logging
from contextlib import closing
from logging.handlers import RotatingFileHandler

from configobj import ConfigObj

from minerva.db import connect

from minerva.directory.alias import flush, store
from minerva.util import parse_size


CONFIG_DEFAULTS = """\
db_uri = postgresql://minerva:minerva@localhost/minerva
module_directory = /usr/local/lib/minerva/aliases
log_directory = /var/log/minerva/
log_filename = create-aliases.log
log_rotation_size = 10MB
log_level = INFO"""


def setup_args_parser():
    parser = argparse.ArgumentParser(description="Create aliases")

    parser.add_argument("-m", "--module",
        help="name of module containing the alias logic")

    parser.add_argument("-f", "--flush", action="store_true", default=False,
        help="flush current aliases of specified type")

    parser.add_argument("-c", "--configfile", dest="configfile",
        default="/etc/create-aliases.conf", help="path to the config file")

    parser.add_argument("-v", "--verbose", action="store_true", default=False,
        help="verbose output")

    parser.add_argument("--generate-configfile", 	dest="generate_configfile",
        action=GenerateConfigFileAction, nargs=0, help="generate base config file")

    return parser.parse_args()


def main():
    args = setup_args_parser()

    if args.generate_configfile:
        print(CONFIG_DEFAULTS)
        return 0

    config = ConfigObj(args.configfile)

    setup_logging(args.verbose)
    setup_file_logging(config["log_directory"], config["log_filename"],
        config["log_rotation_size"], config["log_level"])

    if args.module is None:
        print("no alias module specified")
        return 2

    sys.path.append(config["module_directory"])
    module = __import__(args.module)
    try:
        logging.info("generating aliases: '{}'".format(args.module))

        with closing(connect(config["db_uri"])) as conn:
            if args.flush:
                logging.info("flushing aliases of type {}".format(module.TYPE))
                flush(conn, module.TYPE)

            store(conn, module.get_aliases(conn), module.TYPE)

            conn.commit()

    except Exception:
        traceback.print_exc()
        return 1

    return 0


def setup_logging(verbose):
    root_logger = logging.getLogger("")

    if verbose:
        handler = logging.StreamHandler(sys.stdout)

        root_logger.addHandler(handler)

    root_logger.setLevel(logging.INFO)


def setup_file_logging(directory, filename, rotation_size, level):
    """
    Setup rotating file logging.
    """
    level_map = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL}

    max_log_size = parse_size(rotation_size)

    filepath = os.path.join(directory, filename)
    handler = RotatingFileHandler(filepath, maxBytes=max_log_size, backupCount=5)
    handler.setLevel(level_map[level])

    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    handler.setFormatter(formatter)

    rootlogger = logging.getLogger("")
    rootlogger.setLevel(level_map[level])
    rootlogger.addHandler(handler)


class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(CONFIG_DEFAULTS)
        sys.exit(0)


if __name__ == "__main__":
    sys.exit(main())
