#!/usr/bin/python
# -*- coding: utf-8 -*-
import sys
import os
import argparse
import logging
import datetime
from contextlib import closing
from logging.handlers import RotatingFileHandler
from functools import partial
import traceback

import pytz

from minerva.db import connect
from minerva.db.query import Table, And, Eq, Column, Select
from minerva.db.postgresql import column_exists
from minerva.directory.helpers_v4 import get_datasource_by_id, get_entitytype_by_id

from minerva.util import parse_size
from minerva.util.config import load_config, get_defaults, ConfigError

from minerva.storage.trend.util import quote
from minerva.storage.trend.tables import make_table_name

package_name = "minerva.storage.trend"
script_name = os.path.basename(__file__)
config_file = "{}.conf".format(script_name)


def main():
    config_file_path = os.path.join("/etc/minerva", config_file)

    parser = argparse.ArgumentParser(description="Update views")

    parser.add_argument("-c", "--configfile", default=config_file_path,
            help="path to config file")

    parser.add_argument("--generate-configfile",
            action=GenerateConfigFileAction, nargs=0, help="generate default config file")

    parser.add_argument("--verbose", action="store_true", default=False)

    parser.add_argument("--pretend", action="store_true", default=False,
            help="don't write to database")

    parser.add_argument("-t", "--timestamp",  help="timestamp specifying views "
            "to create (%%Y%%m%%d_%%H%%M%%S). When ommitted now() is used.")

    args = parser.parse_args()

    try:
        config = load_config(get_defaults(package_name, config_file), args.configfile)
    except ConfigError as exc:
        print("error loading configuration: {}".format(exc))
        return 1

    setup_logging(args.verbose)
    setup_file_logging(config["log_directory"], config["log_filename"],
        config["log_rotation_size"], config["log_level"])

    logging.debug("start")

    conn = connect(config["db_uri"])

    tzinfo = pytz.timezone(config["timezone"])

    if not args.timestamp:
        timestamp = datetime.datetime.now()
    else:
        timestamp = datetime.datetime.strptime(args.timestamp, "%Y%m%d_%H%M%S")

    timestamp = tzinfo.localize(timestamp)

    try:
        with closing(conn.cursor()) as cursor:
            views = get_views(cursor)

        for view in views:
            try:
                with closing(conn.cursor()) as cursor:
                    check_view(cursor, timestamp, view)
            except Exception as exc:
                logging.error("fail: {}".format(traceback.format_exc()))
                conn.rollback()
            else:
                conn.commit()
    except Exception as exc:
        logging.error("fail: {}".format(traceback.format_exc()))
        return 1
    else:
        logging.info("success")
        return 0


def check_view(cursor, timestamp, view):
    table_name = view.table_name(timestamp)
    table = Table("trend", table_name)

    if not view_exists(cursor, table):
        logging.info("view {} does not exist".format(table_name))

        view.create(timestamp)(cursor)


class View(object):
    """
    Meta data for creation of views
    """
    def __init__(self):
        self.id = None
        self.datasource = None
        self.entitytype = None
        self.granularity = None
        self.sources = []
        self.sql = None

    def __str__(self):
        lines = ["<{}, {}, {}>".format(self.datasource.name, self.entitytype.name, self.granularity)]

        for s in self.sources:
            lines.append(" -- {}".format(s))

        return "\n".join(lines)

    def table_name(self, timestamp):
        return make_table_name(self.datasource, self.granularity, self.entitytype.name, timestamp)

    def compile_sql(self, timestamp):
        mapping = [(s.name, make_table_name(s.datasource, s.granularity, s.entitytype.name, timestamp)) for s in self.sources]

        result = self.sql

        for name, table_name in mapping:
            result = result.replace("{{source:{}}}".format(name), table_name)

        return result

    def create(self, timestamp):
        def f(cursor):
            sql = self.compile_sql(timestamp)

            view_name = self.table_name(timestamp)

            queries = [
                "CREATE VIEW trend.{} AS {}".format(quote(view_name), sql),
                "ALTER TABLE trend.{} OWNER TO minerva_writer".format(quote(view_name)),
                "GRANT SELECT ON TABLE trend.{} TO minerva".format(quote(view_name))]

            map(cursor.execute, queries)

        return f


class ViewSource(object):
    """
    Meta data for the source tables of views
    """
    def __init__(self):
        self.id = None
        self.name = None
        self.datasource = None
        self.entitytype = None
        self.granularity = None

    def __str__(self):
        return "<{}, {}, {}, {}>".format(self.name, self.datasource.name, self.entitytype.name, self.granularity)


def get_views(cursor):
    query = (
        "SELECT id, description, datasource_id, entitytype_id, granularity, sql "
        "FROM trend.view")

    cursor.execute(query)

    return map(partial(view_from_row, cursor), cursor.fetchall())


def view_from_row(cursor, row):
    id, description, datasource_id, entitytype_id, granularity, sql = row

    view = View()
    view.id = id
    view.sql = sql
    view.description = description
    view.datasource = get_datasource_by_id(cursor, datasource_id)
    view.entitytype = get_entitytype_by_id(cursor, entitytype_id)
    view.granularity = granularity
    view.sources = get_sources_for_view(cursor, id)
    return view


def get_sources_for_view(cursor, view_id):
    query = (
        "SELECT id, name, datasource_id, entitytype_id, granularity "
        "FROM trend.view_source vs "
        "JOIN trend.view_source_link vsl ON vsl.view_source_id = vs.id "
        "WHERE vsl.view_id = %s")

    args = (view_id, )

    cursor.execute(query, args)

    return map(partial(view_source_from_row, cursor), cursor.fetchall())


def view_source_from_row(conn, row):
    id, name, datasource_id, entitytype_id, granularity = row

    view_source = ViewSource()
    view_source.id = id
    view_source.name = name
    view_source.datasource = get_datasource_by_id(conn, datasource_id)
    view_source.entitytype = get_entitytype_by_id(conn, entitytype_id)
    view_source.granularity = granularity
    return view_source


def view_exists(cursor, table):
    criterion = And(
        Eq(Column("relname")),
        Eq(Column("relkind")))

    query = Select(1, from_=Table("pg_class"), where_=criterion)

    args = table.name, "v"

    query.execute(cursor, args)

    return cursor.rowcount > 0


class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(get_defaults(package_name, config_file))
        sys.exit(0)


def setup_logging(verbose):
    root_logger = logging.getLogger("")

    if verbose:
        handler = logging.StreamHandler(sys.stdout)
        root_logger.addHandler(handler)

    root_logger.setLevel(logging.INFO)


def setup_file_logging(directory, filename, rotation_size, level):
    """
    Setup rotating file logging.
    """
    level_map = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL}

    max_log_size = parse_size(rotation_size)

    filepath = os.path.join(directory, filename)
    handler = RotatingFileHandler(filepath, maxBytes=max_log_size, backupCount=5)
    handler.setLevel(level_map[level])

    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    handler.setFormatter(formatter)

    rootlogger = logging.getLogger("")
    rootlogger.setLevel(level_map[level])
    rootlogger.addHandler(handler)


if __name__ == "__main__":
    sys.exit(main())
