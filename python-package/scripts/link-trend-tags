#!/usr/bin/python
"""
Create and link tags for trends
"""
import os
import sys
import re
import argparse
import traceback
import logging
from contextlib import closing
from operator import itemgetter
from itertools import groupby

from configobj import ConfigObj

from minerva.db import connect
from minerva.directory.tag import get_tag, create_tag, NoSuchTagError, \
    get_tag_group, create_tag_group
from minerva.util.config import load_config, get_defaults, ConfigError
from minerva.instance import MinervaInstance

from minerva.storage.trend.tag import tag_trends, flush_tag_links

package_name = "minerva"
script_name = os.path.basename(__file__)
config_file = "{}.conf".format(script_name)


def setup_args_parser():
    default_minerva_instance = os.environ.get("DEFAULT_MINERVA_INSTANCE",
            "default")

    config_file_path = os.path.join("/etc/minerva", config_file)

    parser = argparse.ArgumentParser(
        description="Create tags for trends")

    parser.add_argument("-i", "--instance", default="default",
        help="name of the minerva instance")

    parser.add_argument("-u", "--user", help="user to connect to database")

    parser.add_argument("-t", "--tag-type",
        help="name of module containing tag type definition")

    parser.add_argument("-c", "--configfile", dest="configfile",
        default=config_file_path, help="path to config file")

    parser.add_argument("-v", "--verbose", action="store_true", default=False,
        help="verbose output")

    parser.add_argument("-f", "--flush", action="store_true", default=False,
        help="flush current trend tags of specified type")

    parser.add_argument("--generate-configfile", dest="generate_configfile",
        action=GenerateConfigFileAction, nargs=0, help="generate base config file")

    return parser


def main():
    parser = setup_args_parser()

    args = parser.parse_args()

    try:
        config = load_config(get_defaults(package_name, config_file), args.configfile)
    except ConfigError as exc:
        print("error loading configuration: {}".format(exc))
        return 1

    setup_logging(args.verbose)

    minerva_instance = MinervaInstance.load(args.instance)

    module_directory = os.path.join(minerva_instance.minerva_class().path(), "tags/trend")

    sys.path.append(module_directory)

    module_path = "{}.py".format(os.path.join(module_directory, args.tag_type))

    if not os.path.isfile(module_path):
        print("no tag module '{}'".format(module_path))
        return 1

    module = __import__(args.tag_type)

    user = config.get("database", {}).get("user") or args.user or "minerva_admin"
    db_uri = config.get("db_url") or minerva_instance.get_db_uri(user)

    try:
        with closing(connect(db_uri)) as conn:
            link(conn, module, args.flush)
    except Exception:
        traceback.print_exc()
        return 1

    return 0


def link(conn, module, flush):
    """
    Link trends and tags
    """
    tag_links = module.get_tag_links(conn)

    count = len(tag_links)

    get_tag_name = itemgetter(1)

    tag_names = set(map(get_tag_name, tag_links))

    for tag_name in tag_names:
        try:
            tag = get_tag(conn, tag_name)
        except NoSuchTagError:
            tag_group = create_tag_group(
                conn, module.GROUP_NAME, module.COMPLEMENTARY)
            tag = create_tag(conn, tag_name, tag_group)
        else:
            if flush:
                logging.info("flushing links for tag '{}'".format(tag_name))

                flush_tag_links(conn, tag_name)

    logging.info("storing {} tag links".format(count))

    tag_trends(conn, tag_links)


class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(get_defaults(package_name, config_file))
        sys.exit(0)


def setup_logging(verbose):
    root_logger = logging.getLogger("")

    if verbose:
        handler = logging.StreamHandler(sys.stdout)

        root_logger.addHandler(handler)

    root_logger.setLevel(logging.INFO)


if __name__ == "__main__":
    sys.exit(main())
