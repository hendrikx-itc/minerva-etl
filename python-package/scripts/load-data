#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
Load custom data provided by external module
"""
__docformat__ = "restructuredtext en"

__copyright__ = """
Copyright (C) 2008-2013 Hendrikx-ITC B.V.

Distributed under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option) any later
version.  The full license is in the file COPYING, distributed as part of
this software.
"""
import os
import sys
import logging
import argparse
import datetime
from contextlib import closing
from functools import partial
from logging.handlers import RotatingFileHandler

from dateutil import parser as datetime_parser
import pytz

import psycopg2.extras

from minerva.db import parse_db_url
from minerva import storage
from minerva.util.config import load_config, get_defaults, ConfigError
from minerva.directory import helpers_v4

TIMEZONE = "Europe/Amsterdam"

package_name = "minerva"
script_name = os.path.basename(__file__)
config_file = "{}.conf".format(script_name)


LEVEL_MAP = {
    "DEBUG": logging.DEBUG,
    "INFO": logging.INFO,
    "WARNING": logging.WARNING,
    "ERROR": logging.ERROR,
    "CRITICAL": logging.CRITICAL}


def main():
    config_file_path = os.path.join("/etc/minerva", config_file)

    parser = argparse.ArgumentParser(
        description="Script for loading data generated by external module")

    parser.add_argument(
        "-m", "--module",
        help="name of the module containing data generation magic")

    parser.add_argument(
        "-c", "--configfile", dest="configfile",
        default=config_file_path, help="the path to config file")

    parser.add_argument(
        "--generate-configfile", dest="generate_configfile",
        action=GenerateConfigFileAction, nargs=0,
        help="generate base config file")

    parser.add_argument("--datasource", help="name of datasource")
    parser.add_argument("--entitytype", help="name of entitytype")

    parser.add_argument(
        "--storage-type", default="trend", help="storage type/format to use")

    parser.add_argument(
        "--verbose", action="store_true", default=False,
        help="show verbose output")

    parser.add_argument(
        "--debug", action="store_true", default=False,
        help="log and show debug output")

    parser.add_argument(
        "-t", "--timestamp",
        help="timestamp to post process (yyyy-mm-ddThh:mm:ss+hh:ss)")

    args = parser.parse_args()

    try:
        config = load_config(
            get_defaults(package_name, config_file), args.configfile)
    except ConfigError as exc:
        print("error loading configuration: {}".format(exc))
        return 1

    logging_conf = config["logging"]

    log_level_name = logging_conf["level"]
    log_level = LEVEL_MAP[log_level_name]

    if args.debug:
        log_level = logging.DEBUG

    logger = setup_logging(log_level, logging_conf["directory"],
                           logging_conf["base_name"])

    if args.verbose or args.debug:
        enable_console_logging(logger)

    if args.timestamp:
        ts = datetime_parser.parse(args.timestamp)
    else:
        tzinfo = pytz.timezone(TIMEZONE)
        ts = tzinfo.localize(datetime.datetime.now())

    db_url = config["database"]["url"]

    if log_level == logging.DEBUG:
        db_logger = logger
    else:
        db_logger = None

    if args.module is None:
        print("no module specified")
        return 2

    sys.path.append(config["module_directory"])
    module = __import__(args.module)

    with closing(connect(db_url, db_logger)) as conn:
        with closing(conn.cursor()) as cursor:

            entitytype = helpers_v4.get_entitytype(cursor, args.entitytype)
            datasource = helpers_v4.get_datasource(cursor, args.datasource)
            plugin = storage.get_plugin(args.storage_type)(conn)

            fields = module.fields()
            refined_data_rows = module.refined_data_rows(cursor, ts)

            if args.storage_type == "attribute":
                plugin.store(datasource, entitytype, ts, fields,
                             refined_data_rows)
            elif args.storage_type == "trend":
                refined_data_rows = plugin.refine_data_rows(raw_data_rows)

                plugin.store(datasource, entitytype, granularity, ts, fields,
                             refined_data_rows)


def connect(db_url, logger=None):
    scheme, user, password, host, port, database = parse_db_url(db_url)

    assert scheme == "postgresql", "Only PostgreSQL connections are supported"

    create_connection = partial(
        psycopg2.connect, database=database, user=user, password=password,
        host=host, port=port)

    if logger:
        conn = create_connection(
            connection_factory=psycopg2.extras.LoggingConnection)

        conn.initialize(logger)
    else:
        conn = create_connection()

    return conn


def enable_console_logging(logger):
    handler = logging.StreamHandler(sys.stdout)

    logger.addHandler(handler)


def setup_logging(level, directory, base_name):
    """
    Setup rotating file logging.
    """
    max_log_size = 1024 * 1024 * 10
    backup_count = 5

    logger = logging.getLogger("")
    logger.setLevel(level)

    filepath = os.path.join(directory, base_name)
    handler = RotatingFileHandler(
        filepath, maxBytes=max_log_size, backupCount=backup_count)
    handler.setLevel(level)

    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    handler.setFormatter(formatter)

    logger.addHandler(handler)
    return logger


class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(get_defaults(package_name, config_file))
        sys.exit(0)


if __name__ == "__main__":
    main()
